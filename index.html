<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Todo (Event-Log, Immutable Past)</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<style>
body { font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial, sans-serif; margin:0; background:#f0f0f0; }
header { background:#6200ee; color:#fff; padding:0.6em 0.8em; display:flex; align-items:center; gap:0.8em; justify-content:space-between; }
header .title { font-weight:600; }
header input[type=date] { font-size:1em; padding:0.3em 0.5em; border-radius:4px; border:none; }

#metrics { margin:1em; height:1.2em; border-radius:10px; background:#ddd; overflow:hidden; }
#metrics > div { height:100%; border-radius:10px; text-align:right; padding-right:0.5em; color:white; font-weight:600; line-height:1.2em; transition:width .2s ease; }

main { padding:1em; max-width:800px; margin:0 auto; }

.list { background:#fff; border-radius:8px; padding:0.9em; margin:0.8em 0; border:1px solid #ddd; box-shadow:0 1px 2px rgba(0,0,0,.03); }
.list-header { display:flex; align-items:center; gap:0.6em; }
.list-header .name { flex:1 1 auto; font-weight:600; cursor:pointer; user-select:none; padding:0.15em 0.25em; border-radius:4px; }
.list-header .meta { margin-left:auto; color:#555; font-size:0.9em; }

.task { display:flex; align-items:center; gap:0.4em; margin:0.35em 0; }
.task input[type=checkbox]{ margin-right:0.1em; }
.task .text { flex:1 1 auto; cursor:pointer; user-select:none; padding:0.15em 0.25em; border-radius:4px; }
.task .delete-btn{ border:none; background:none; cursor:pointer; font-size:1em; color:#f44336; padding:0.1em 0.2em; }

.new-item { border:1px dashed #ccc; padding:0.5em; margin-top:0.5em; border-radius:6px; background:#fafafa; }
.new-item input { width:100%; border:none; outline:none; background:transparent; font-size:1em; }

#newListInline { padding-bottom:2em; }
#newListInlineOptions button { padding:0.4em 0.6em; border:1px solid #6200ee; border-radius:4px; background:#fff; cursor:pointer; }

.day-toggle { display:inline-block; padding:0.25em 0.5em; border:1px solid #6200ee; border-radius:4px; cursor:pointer; user-select:none; background:#fff; color:#6200ee; min-width:2.2em; text-align:center; }
.day-toggle.active { background:#6200ee; color:#fff; }

/* Toasts: fixed positioning, stacked, pointer-events none so clicks pass through */
#toastContainer { position:fixed; top:1em; left:50%; transform:translateX(-50%); z-index:1000; display:flex; flex-direction:column; align-items:center; gap:0.4em; pointer-events:none; }
.toast { background:#333; color:#fff; padding:0.5em 0.9em; border-radius:6px; box-shadow:0 2px 10px rgba(0,0,0,.25);
         opacity:0; transform:translateY(-6px); transition:opacity .18s ease, transform .18s ease; max-width:80vw; }
.toast.show { opacity:1; transform:translateY(0); }

/* Dragging: prevent text selection during drag */
.draggable { cursor:grab; }
.drag-over { outline:2px dashed #6200ee; outline-offset:4px; }
.dragging, .dragging * { user-select:none !important; }
</style>
</head>
<body>
<header>
  <div class="title">Todo</div>
  <div style="display:flex; align-items:center; gap:0.6em;">
    <label style="font-size:.95em; opacity:.9;">Date</label>
    <input type="date" id="currentDate">
  </div>
</header>

<div id="metrics"><div style="width:0%;background:#4caf50;">0%</div></div>

<main>
  <div id="lists"></div>

  <!-- Inline New List -->
  <div id="newListInline" style="margin-top:0.8em;">
    <div class="new-item">
      <input type="text" id="newListInlineName" placeholder="New list..." />
    </div>

    <div id="newListInlineOptions" style="display:none; margin-top:0.5em; background:#fff; border:1px solid #ccc; border-radius:8px; padding:0.7em;">
      <label style="display:block; margin-bottom:0.35em;">
        Type:
        <select id="newListInlineType" style="margin-left:0.4em;">
          <option value="once">One-time</option>
          <option value="future">Future</option>
          <option value="repeat">Repeats</option>
          <option value="untilCompleted">Until completed</option>
        </select>
      </label>

      <div id="newListInlineFuture" style="display:none; margin-bottom:0.4em;">
        Start date: <input type="date" id="newListInlineStart">
      </div>

      <div id="newListInlineDays" style="display:none;">
        <div style="margin-bottom:0.2em;">Repeat on:</div>
        <div id="newListInlineDaysButtons"></div>
      </div>

      <div style="margin-top:0.6em; display:flex; gap:0.4em;">
        <button id="newListInlineCreate">Create</button>
        <button id="newListInlineCancel" type="button">Cancel</button>
      </div>
    </div>
  </div>
</main>

<div id="toastContainer"></div>

<script>
/* ===== small helpers ===== */
const $ = (sel, root=document)=>root.querySelector(sel);
const $$ = (sel, root=document)=>Array.from(root.querySelectorAll(sel));
const on = (el, ev, fn)=>el.addEventListener(ev, fn);
const storage = {
  save:(k,v)=>localStorage.setItem(k, JSON.stringify(v)),
  load:(k,def)=>{ try{ return JSON.parse(localStorage.getItem(k) ?? JSON.stringify(def)); } catch { return def; } }
};
const todayStr = ()=> new Date().toISOString().slice(0,10);
const fmt = (d)=> d.toISOString().slice(0,10);
const parseYMD = (s)=>{ const [y,m,d]=s.split('-').map(Number); return new Date(y,m-1,d); };
const addDays = (s, n)=>{ const d=parseYMD(s); d.setDate(d.getDate()+n); return fmt(d); };
const prevDay = (s)=> addDays(s,-1);
const EVENTS_KEY='events';
let events = storage.load(EVENTS_KEY, []);

/* Toasts: reliable show/hide */
function showToast(msg){
  const c = $('#toastContainer');
  const t = document.createElement('div');
  t.className='toast'; t.textContent=msg; c.appendChild(t);
  // force next-frame to apply transition
  requestAnimationFrame(()=> t.classList.add('show'));
  setTimeout(()=> {
    t.classList.remove('show');
    t.addEventListener('transitionend', ()=> t.remove(), { once:true });
  }, 2200);
}

const currentDateStr = ()=> $('#currentDate').value || todayStr();
const isPastView = ()=> currentDateStr() < todayStr();

/* ===== same-day event compaction + append ===== */
function sortEventsStable(arr){
  arr.sort((a,b)=> (a.effectiveDate<b.effectiveDate?-1: a.effectiveDate>b.effectiveDate?1: a.at-b.at));
}
function spliceMany(arr, idxs){
  idxs.sort((a,b)=>a-b).forEach((i,off)=>arr.splice(i-off,1));
}
function lastIndexToday(arr, day, pred){
  for(let i=arr.length-1;i>=0;i--){
    const x=arr[i]; if(x.effectiveDate!==day) break;
    if(pred(x)) return i;
  } return -1;
}
function appendEvent(ev){
  const e = { ...ev, at: Date.now(), effectiveDate: todayStr() };
  const day = e.effectiveDate;
  const arr = events.slice();

  if (e.t==='LIST_DELETE'){
    const k = lastIndexToday(arr, day, x=>x.t==='LIST_CREATE' && x.listId===e.listId);
    if (k!==-1){
      const after = arr.slice(k+1).filter(x=>x.effectiveDate===day);
      const intervening = after.some(x=> x.listId===e.listId && x.t!=='LIST_RENAME');
      if(!intervening){ spliceMany(arr,[k]); storage.save(EVENTS_KEY,events=arr); return; }
    }
  }
  if (e.t==='ITEM_DELETE'){
    const k = lastIndexToday(arr, day, x=>x.t==='ITEM_ADD' && x.listId===e.listId && x.itemId===e.itemId);
    if (k!==-1){
      const after = arr.slice(k+1).filter(x=>x.effectiveDate===day);
      const intervening = after.some(x=> x.listId===e.listId && x.itemId===e.itemId && x.t!=='ITEM_TEXT_SET');
      if(!intervening){
        const del=[k];
        after.forEach((x,i)=>{ if (x.listId===e.listId && x.itemId===e.itemId && x.t==='ITEM_TEXT_SET') del.push(k+1+i); });
        spliceMany(arr, del); storage.save(EVENTS_KEY,events=arr); return;
      }
    }
  }
  if (e.t==='ITEM_TEXT_SET'){
    const rm=[];
    for(let i=arr.length-1;i>=0;i--){
      const x=arr[i]; if(x.effectiveDate!==day) break;
      if (x.listId===e.listId && x.itemId===e.itemId && x.t==='ITEM_TEXT_SET') rm.push(i);
      if (x.listId===e.listId && x.itemId===e.itemId && x.t==='ITEM_ADD'){
        x.text = e.text; spliceMany(arr,rm); storage.save(EVENTS_KEY,events=arr); return;
      }
    }
    if (rm.length) spliceMany(arr,rm);
  }
  if (e.t==='ITEM_COMPLETE_SET'){
    const rm=[]; for(let i=arr.length-1;i>=0;i--){
      const x=arr[i]; if(x.effectiveDate!==day) break;
      if (x.t==='ITEM_COMPLETE_SET' && x.listId===e.listId && x.itemId===e.itemId) rm.push(i);
    }
    if (rm.length) spliceMany(arr,rm);
  }
  if (e.t==='VISIBLE_ORDER_SET' || e.t==='LIST_ORDER_SET'){
    const rm=[]; for(let i=arr.length-1;i>=0;i--){
      const x=arr[i]; if(x.effectiveDate!==day) break;
      if ((e.t==='VISIBLE_ORDER_SET' && x.t==='VISIBLE_ORDER_SET' && x.listId===e.listId) ||
          (e.t==='LIST_ORDER_SET' && x.t==='LIST_ORDER_SET')) rm.push(i);
    }
    if (rm.length) spliceMany(arr,rm);
  }
  if (e.t==='LIST_RENAME'){
    const j = lastIndexToday(arr, day, x=>x.t==='LIST_RENAME' && x.listId===e.listId);
    if (j!==-1) spliceMany(arr,[j]);
  }

  arr.push(e);
  sortEventsStable(arr);
  storage.save(EVENTS_KEY, events = arr);
}

/* ===== materialize ===== */
function isActiveListOnDate(list, dateObj){
  const dStr = fmt(dateObj);
  if (list.type==='future' && dStr < list.start) return false;
  if (list.start && dStr < list.start) return false;
  if (list.end && dStr > list.end) return false;
  if (list.daysOfWeek && !list.daysOfWeek.includes(dateObj.getDay())) return false;
  return true;
}
function materialize(dateStr){
  sortEventsStable(events);

  const lists = new Map();
  const order = [];
  const items = new Map(); // listId -> Map(itemId -> {id,text,createdAt,deletedAt})
  const completes = new Map(); // "l:i" -> [{date,completed}]

  for(const e of events){
    if (e.effectiveDate > dateStr) break;
    switch(e.t){
      case 'LIST_CREATE': {
        if(!lists.has(e.listId)){
          lists.set(e.listId, { id:e.listId, name:e.name||'', type:e.type||'once',
            start:e.start||e.effectiveDate, end:e.end||null, daysOfWeek:e.daysOfWeek||null, _reorders:[] });
          order.push(e.listId);
        }
        break;
      }
      case 'LIST_RENAME': { const l=lists.get(e.listId); if(l) l.name=e.name; break; }
      case 'LIST_DELETE': {
        lists.delete(e.listId);
        const i=order.indexOf(e.listId); if(i>-1) order.splice(i,1);
        items.delete(e.listId);
        [...completes.keys()].forEach(k=>k.startsWith(e.listId+':') && completes.delete(k));
        break;
      }
      case 'LIST_ORDER_SET': {
        const filtered = e.order.filter(id=>lists.has(id));
        if (filtered.length){ order.length=0; order.push(...filtered); }
        break;
      }
      case 'ITEM_ADD': {
        if(!lists.has(e.listId)) break;
        const m = items.get(e.listId) || new Map();
        m.set(e.itemId, { id:e.itemId, text:e.text||'', createdAt:e.effectiveDate, deletedAt:null });
        items.set(e.listId, m);
        break;
      }
      case 'ITEM_TEXT_SET': {
        const m=items.get(e.listId); if(!m) break;
        const it=m.get(e.itemId); if(it) it.text=e.text; break;
      }
      case 'ITEM_DELETE': {
        const m=items.get(e.listId); if(!m) break;
        const it=m.get(e.itemId); if(it) it.deletedAt=e.effectiveDate; break;
      }
      case 'ITEM_COMPLETE_SET': {
        const k=`${e.listId}:${e.itemId}`;
        const a=completes.get(k)||[]; a.push({date:e.effectiveDate, completed:!!e.completed}); completes.set(k,a); break;
      }
      case 'VISIBLE_ORDER_SET': {
        const l=lists.get(e.listId); if(!l) break;
        l._reorders.push({ date:e.effectiveDate, order:e.order.slice() }); break;
      }
    }
  }

  const mats = order.map(id=>lists.get(id)).filter(Boolean);

  for(const l of mats){
    const m = items.get(l.id) || new Map();
    let arr = [...m.values()].sort((a,b)=> (a.createdAt<b.createdAt?-1: a.createdAt>b.createdAt?1: a.id-b.id));
    if (l._reorders){
      for(const r of l._reorders){
        if (r.date > dateStr) continue;
        const visible = arr.filter(x=> (x.createdAt||'0000-00-00') <= r.date && r.date < (x.deletedAt||'9999-12-31'));
        const visById = new Map(visible.map(x=>[x.id,x]));
        const orderedVis = r.order.map(id=>visById.get(+id)||visById.get(id)).filter(Boolean);
        const nonVis = arr.filter(x=>!visById.has(x.id));
        arr = orderedVis.concat(nonVis);
      }
    }
    l.items = arr.filter(x=> x.createdAt<=dateStr && dateStr < (x.deletedAt||'9999-12-31'));
    delete l._reorders;
  }

  // Per-item completion at dateStr
  const completed = {};
  for(const l of mats){
    for(const it of l.items){
      const key = `${l.id}:${it.id}`;
      const log = completes.get(key)||[];
      if (l.type==='untilCompleted'){
        let v=false; for(const ev of log){ if(ev.date<=dateStr) v=ev.completed; }
        completed[it.id]=!!v;
      } else {
        const same = log.filter(ev=>ev.date===dateStr);
        completed[it.id] = same.length ? same[same.length-1].completed : false;
      }
    }
  }

  // Hide "untilCompleted" lists starting the day AFTER the first day all visible items were completed.
  // This checks "all completed as of the previous day".
  const prev = prevDay(dateStr);
  const isAllCompletedAsOf = (l, dStr)=>{
    const m = items.get(l.id) || new Map();
    const visibleItems = [...m.values()].filter(x=> x.createdAt<=dStr && dStr < (x.deletedAt||'9999-12-31'));
    if (visibleItems.length===0) return false; // no items -> not complete yet
    for(const it of visibleItems){
      const key=`${l.id}:${it.id}`;
      const log = completes.get(key)||[];
      let v=false; for(const ev of log){ if(ev.date<=dStr) v=ev.completed; }
      if (!v) return false;
    }
    return true;
  };

  const dateObj = parseYMD(dateStr);
  const activeLists = mats.filter(l=>{
    if (!isActiveListOnDate(l,dateObj)) return false;
    if (l.type!=='untilCompleted') return true;
    // must have started
    if (dateStr < (l.start || '0000-00-00')) return false;
    // drop if all were completed as of yesterday
    return !isAllCompletedAsOf(l, prev);
  });

  return { lists: activeLists, completed };
}

/* ===== DnD ===== */
function moveInArray(arr, from, to){ if(from===to) return; const x=arr.splice(from,1)[0]; arr.splice(to,0,x); }
function enableDragSort(container, itemSelector, onMoveIndex){
  let dragSrcIdx=null;
  $$(itemSelector, container).forEach((el, idx)=>{
    el.draggable=true; el.classList.add('draggable'); el.dataset.dndIndex=String(idx);
    on(el,'dragstart',e=>{ document.body.classList.add('dragging'); dragSrcIdx=+el.dataset.dndIndex; e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain', String(dragSrcIdx)); });
    on(el,'dragover',e=>{ e.preventDefault(); e.dataTransfer.dropEffect='move'; el.classList.add('drag-over'); });
    on(el,'dragleave',()=> el.classList.remove('drag-over'));
    on(el,'drop',e=>{ e.preventDefault(); el.classList.remove('drag-over'); const from=dragSrcIdx ?? +e.dataTransfer.getData('text/plain'); const to=+el.dataset.dndIndex; if(Number.isInteger(from)&&Number.isInteger(to)) onMoveIndex(from,to); });
    on(el,'dragend',()=>{ document.body.classList.remove('dragging'); $$(itemSelector,container).forEach(n=>n.classList.remove('drag-over')); });
  });
}

/* ===== small UI primitives ===== */
function longPress(el, ms, fn){
  let t=null;
  const start=()=>{ t=setTimeout(fn, ms); };
  const cancel=()=>{ clearTimeout(t); t=null; };
  ['mousedown','touchstart'].forEach(ev=>on(el,ev,start));
  ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev=>on(el,ev,cancel));
}
function makeEditable(spanEl, initial, onSave){
  longPress(spanEl, 500, ()=>{
    if (isPastView()) return;
    const input=document.createElement('input');
    input.type='text'; input.value=initial; input.style.width='100%';
    const save=()=>{ const v=input.value.trim(); if(v && v!==initial) onSave(v); render(); };
    input.onblur=save; on(input,'keydown',e=>{ if(e.key==='Enter') input.blur(); });
    spanEl.replaceWith(input); input.focus(); input.select();
  });
}
function confirmDelete(msg, fn){ if (isPastView()) return; if (confirm(msg)) { fn(); render(); } }

/* ===== render ===== */
const elLists = $('#lists');
function render(){
  const dateStr = currentDateStr();
  const { lists, completed } = materialize(dateStr);

  elLists.innerHTML='';
  let total=0, done=0;

  lists.forEach((list)=>{
    const card = document.createElement('div'); card.className='list'; card.dataset.listId=list.id;

    const header = document.createElement('div'); header.className='list-header';
    const name = document.createElement('span'); name.className='name'; name.textContent=list.name; name.title='Long-press to rename';
    makeEditable(name, list.name, v=>appendEvent({ t:'LIST_RENAME', listId:list.id, name:v }));
    header.appendChild(name);

    const meta = document.createElement('div'); meta.className='meta';
    meta.textContent =
      (list.type==='repeat')
        ? 'Repeats: ' + (list.daysOfWeek||[]).map(i=>['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][i]).join(' ')
        : (list.type==='future' ? `Starts ${list.start}`
           : (list.type==='untilCompleted' ? 'Until completed' : 'One-time'));
    header.appendChild(meta);

    const delBtn=document.createElement('button'); delBtn.title='Delete list'; delBtn.textContent='âŒ';
    on(delBtn,'click',()=> confirmDelete('Delete this list?', ()=>appendEvent({ t:'LIST_DELETE', listId:list.id })));
    header.appendChild(delBtn);
    card.appendChild(header);

    list.items.forEach((it)=>{
      const row=document.createElement('div'); row.className='task'; row.dataset.itemId=it.id;

      const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=!!completed[it.id];
      on(cb,'change',()=>{
        if (isPastView()) { cb.checked=!cb.checked; return; }
        appendEvent({ t:'ITEM_COMPLETE_SET', listId:list.id, itemId:it.id, completed:cb.checked });
        render();
      });
      row.appendChild(cb);

      const text=document.createElement('span'); text.className='text'; text.textContent=it.text; text.title='Tap to toggle; long-press to edit';
      on(text,'click',()=>{ if(isPastView()) return; appendEvent({ t:'ITEM_COMPLETE_SET', listId:list.id, itemId:it.id, completed:!cb.checked }); render(); });
      makeEditable(text, it.text, v=>appendEvent({ t:'ITEM_TEXT_SET', listId:list.id, itemId:it.id, text:v }));
      row.appendChild(text);

      if(!isPastView()){
        const del=document.createElement('button'); del.className='delete-btn'; del.title='Delete item'; del.textContent='ðŸ—‘ï¸';
        on(del,'click',()=> confirmDelete('Delete this item?', ()=>appendEvent({ t:'ITEM_DELETE', listId:list.id, itemId:it.id })));
        row.appendChild(del);
      }

      card.appendChild(row);
      total++; if(cb.checked) done++;
    });

    if(!isPastView()){
      const add=document.createElement('div'); add.className='new-item';
      const inp=document.createElement('input'); inp.type='text'; inp.placeholder='New item...';
      on(inp,'keydown',e=>{
        if(e.key==='Enter'){
          const v=inp.value.trim(); if(!v) return;
          appendEvent({ t:'ITEM_ADD', listId:list.id, itemId:Date.now(), text:v });
          inp.value=''; render();
        }
      });
      add.appendChild(inp); card.appendChild(add);
    }

    elLists.appendChild(card);
  });

  // metrics
  const pct = total?Math.round(done/total*100):0;
  const bar = $('#metrics > div');
  bar.style.width = pct + '%';
  bar.textContent = pct + '%';
  bar.style.background = pct<50 ? '#f44336' : (pct<80 ? '#ff9800' : '#4caf50');

  if(!isPastView()){
    const listCards = $$('.list', elLists);
    if (listCards.length>1){
      enableDragSort(elLists, '.list', (from,to)=>{
        const ids = listCards.map(x=>x.dataset.listId);
        moveInArray(ids, from, to);
        appendEvent({ t:'LIST_ORDER_SET', order: ids });
        render();
      });
    }
    listCards.forEach(listCard=>{
      const listId = listCard.dataset.listId;
      const items = $$('.task', listCard);
      if(items.length>1){
        enableDragSort(listCard, '.task', (from,to)=>{
          const ordered = $$('.task', listCard).map(x=>+x.dataset.itemId);
          moveInArray(ordered, from, to);
          appendEvent({ t:'VISIBLE_ORDER_SET', listId, order: ordered });
          render();
        });
      }
    });
  }
}

/* ===== new-list inline creator ===== */
const inlineName   = $('#newListInlineName');
const inlineOpts   = $('#newListInlineOptions');
const inlineType   = $('#newListInlineType');
const inlineFuture = $('#newListInlineFuture');
const inlineStart  = $('#newListInlineStart');
const inlineDays   = $('#newListInlineDays');
const daysWrap     = $('#newListInlineDaysButtons');

(function buildDayButtons(){
  const frag=document.createDocumentFragment();
  ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach((label,i)=>{
    const d=document.createElement('div'); d.className='day-toggle'; d.dataset.day=String(i); d.textContent=label; frag.appendChild(d);
  });
  daysWrap.appendChild(frag);
  $$('.day-toggle', daysWrap).forEach(btn=>{
    const toggle=(e)=>{ e.preventDefault(); btn.classList.toggle('active'); };
    on(btn,'click',toggle); on(btn,'touchstart',toggle);
  });
})();
function openInlineOptions(){
  if(inlineName.value.trim()==='') return;
  inlineOpts.style.display='block';
  inlineStart.value=currentDateStr();
}
function closeInlineOptions(clear=true){
  inlineOpts.style.display='none';
  if(clear){
    inlineName.value=''; inlineType.value='once';
    inlineFuture.style.display='none'; inlineDays.style.display='none';
    $$('.day-toggle.active', daysWrap).forEach(b=>b.classList.remove('active'));
  }
}
on(inlineName,'focus', openInlineOptions);
on(inlineName,'input', openInlineOptions);
on(inlineName,'keydown', e=>{
  if(e.key==='Enter'){ openInlineOptions(); inlineType.focus(); }
  if(e.key==='Escape') closeInlineOptions(true);
});
on(inlineType,'change', ()=>{
  const v=inlineType.value;
  inlineFuture.style.display = (v==='future') ? 'block' : 'none';
  inlineDays.style.display   = (v==='repeat') ? 'block' : 'none';
});
$('#newListInlineCancel').onclick = ()=> closeInlineOptions(true);
$('#newListInlineCreate').onclick = ()=>{
  const name = inlineName.value.trim(); if(!name) return;
  const type = inlineType.value;
  const current = currentDateStr();
  const start  = (type==='future') ? (inlineStart.value || current) : current;
  const days   = (type==='repeat') ? $$('.day-toggle.active', daysWrap).map(b=>+b.dataset.day) : null;
  if(type==='repeat' && (!days || !days.length)) return showToast('Select repeat days');

  const listId = 'L' + Date.now();
  appendEvent({ t:'LIST_CREATE', listId, name, start, end:(type==='once'?start:null), daysOfWeek:days, type });
  render();

  const all = $$('.list', $('#lists'));
  if(all.length) all[all.length-1].scrollIntoView({behavior:'smooth', block:'end'});
  closeInlineOptions(true);
};
on(inlineOpts,'keydown',e=>{
  if(e.key==='Enter') $('#newListInlineCreate').click();
  if(e.key==='Escape') closeInlineOptions(true);
});

/* ===== init ===== */
window.onload = function(){
  if (!$('#currentDate').value) { $('#currentDate').value = todayStr(); }
  $('#currentDate').onchange = render;

  if (events.length===0){
    const listId = 'L' + Date.now();
    appendEvent({ t:'LIST_CREATE', listId, name:'My Tasks', start: todayStr(), end: null, daysOfWeek:null, type:'once' });
    appendEvent({ t:'ITEM_ADD', listId, itemId: Date.now()+1, text:'Try checking me' });
  }
  render();
};
</script>
</body>
</html>
